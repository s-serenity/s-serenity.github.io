{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"第一篇 Markdown","text":"第一篇 Markdown （Typora）基础语法目录标题篇级数个#加空格，如# 表示后面的文字作为一级标题，## 表示后面的文字作为二级标题。 字体篇加粗：将想要加粗的文字在左右用两个*号括起来 ： **加粗** 斜体：将想要斜体的文字在左右用一个*号括起来 ： 斜体加粗：将想要斜体的文字在左右用三个*号括起来 删除线：将想要加删除线的文字在左右用两个~号括起来波浪线 段落篇 生成目录：[toc]， 但是hexo上传博客用此方法显示目录不成功ORZ。 分割线：三个及以上的-或者*，试一试 无序列表：就是这个前面的小黑点，一个+-或者*加上空格，后面跟上文字。 有序列表：数字标号的。数字加点加上空格 这是第一个 这是第二个 插入类 插入图片：![图片下方的文字](图片地址 &quot;图片标题&quot;) 拿一张试试： 插入超链接：[超链接名称](超链接地址 &quot;标题&quot;) 试试：我的博客 插入公式：$$包含TeX 或 LaTeX 格式的数学公式。 插入表格：|分列，-分割表头和内容，左右两边加：文字居中，只加一边文字偏哪边，默认偏左。 举例 1234表头|表头 --|--内容|内容内容|内容 ​ 试一个：没有成功诶，需要在两端也加上|才会显示表格，可是把最后一行作为表头显示了，emmm，应该是编辑器导致的差异。不过Typora可以很方便地直接右击插入表格。。。 表头 表头 内容 内容 内容 内容 插入代码块 单行代码：一个反引号`括起来，反引号就是Esc下面那个键，记得换成英文输入法。 print('hello world!') 多行代码：三个反引号`括起来。 12import numpy as npimport pandas as pd ​","link":"/2020/03/14/Markdown/"},{"title":"My first blog","text":"This is my first blog which is just for test. Happy~I will present my learning process in this blog from today on. Fighting~","link":"/2018/12/21/My-first-blog/"},{"title":"probability","text":"Finally my studying process began, APS verification is really complicated and cost me several days.Keeping calm is what I tried to do recently.Anyway, today I learnt something about belief propagation.算了,还是打中文。今天终于看到一个比较好的关于先验、后验和似然的通俗解释，先验概率就是基于历史数据的统计经验，后验概率是在已知结果发生时推断原因的概率，似然概率是已知原因推断结果的概率。","link":"/2019/01/07/probability/"},{"title":"第三篇 git相关(1)","text":"什么是GitGit is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. 什么是GitHubGitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。 使用Git假设已经在电脑上安装好了Git，并配好了环境，在windows下，文件夹下右击出现了 Git Bash Here，就说明已经安装好了。 使用git需要首先建立一个仓库，之后就可以在这个仓库中对代码进行各种操作，过程中会使用到各种git命令，下面就介绍一下每个git命令的具体作用。 Git 基础命令git init用于初始化一个仓库。在某个文件夹下打开Git Bash，运行完这个命令，文件夹下会生成一个.git文件夹，这个文件夹会记录以后的变更行为，但想要真正地追踪这些变更，还需要更多的操作，只有处于tracked状态下的文件，git才会追踪，后面会具体介绍。 git status用于查看仓库中所有文件的状态。Git中文件有4种状态：untracked， unmodified , modified, staged，后三种状态属于tracked，这几个状态体现了git的原理。 新建一个文件的时候，这个文件处于untracked状态，对这个文件使用了 git add之后，这个文件进入staged状态，也就是暂存区，使用了git commit之后，这个文件进入unmodified状态，这才是实际提交了改动，如果编辑了这个文件，对这个文件进行了更改，便进入了modified状态。 git add在上部分有介绍过，但是这个命令并不是添加文件到某个项目中的意思，准确地说这个命令是把想要提交的内容添加到准备提交的集合里，可以用这个命令来追踪新文件(add the file)，暂存文件（stage the file），或者其它在commit之前的操作。如果在运行了git add之后又修改了文件，没有再次运行git add，就运行了commit，commit的是修改之前的内容。那么是不是每一次都要反复操作git add呢，其实还有别的方法可以跳过暂存区这一步，下面会说明。 git commit是提交变化到仓库里，提交到仓库里的几乎总是可以恢复的，后面会介绍如何恢复。git commit -a就可以跳过暂存区这一步，因为-a包含了所有改动过的文件。git commit -m可以加上这次提交的描述， git rm用于删除文件，这里的删除有两种含义，从Git中删除和从工作目录中删除，如果只是想要Git不在追踪这个文件，需要使用git rm --cached。 git log用于回顾提交历史，运行这个命令可以看到提交的SHA-1 校验和，作者，提交时间和具体提交的内容。如果想要复原到某次提交时候的版本，这个命令是非常重要的，通过拿到每次提交的SHA-1 校验和，可以追踪到对应的版本。 git reset HEAD 用于取消暂存文件。 git checkout --用于撤销所作的修改。 Git 分支分支就是与主线相对的，每个人都可以使用各自的分支进行工作，而不影响主线。在许多版本控制系统中，是需要创建一个完整的源项目副本来创建分支的，而Git不是这样的，Git处理分支的方式非常轻量，分支之间的操作非常迅速。 要理解Git是如何处理分支的，就要理解Git是如何实现对文件的追踪的。Git保存的是不同时刻的快照（Snapshot）,进行提交操作时，Git会保存一个提交对象，这个对象包含了一个指向暂存内容快照的指针，还包含了作者、邮箱等内容以及指向它的父对象的指针，如果是第一次提交，是没有父对象的，而之后的提交，其父对象就是上一次提交。Git的分支，本质上就是指向提交对象的可变指针，所以不同的分支可以指向不同的内容，从而互不影响，而且Git的分支实质上就是一个包含所致对象校验和的文件，所以其创建和销毁都非常高效。 git branch就是创建分支的命令，这个命令会在当前的提交快照上创建一个指针。Git通过一个HEAD的特殊指针指向当前所在的本地分支，从而可以知道自己当前在哪一个分支上。 git branch -d用于删除分支。 git checkout是切换分支的命令。 git merge用于合并分支。当合并分支产生冲突时，Git会停下来，这时候需要手动解决这些冲突，解决完冲突之后，使用git add命令将冲突文件标记为冲突已解决。 远程仓库之前所述的内容，都是基于本地的操作，而如果想要在Git项目上进行协作，就需要一个公共的空间供项目参与者进行共同编辑，这就是远程仓库。远程仓库是指托管在因特网或其他网络中的你的项目的版本库，使用命令新建远程仓库的操作与本地是一致的，在github上create repository就可以新建一个远程仓库，本地和远程仓库之间通过SSH连接，完成SSH的公钥设置之后， 想要实现本地与远程仓库的内容交换，使用以下介绍的命令。 git remote add &lt;shortname&gt; &lt;url&gt;用于添加一个新的远程仓库。 git fetch用于从远程仓库中获取本地没有的数据，但是这个命令指挥把数据下载到本地仓库，并不会与本地仓库自动合并，想要实现自动合并，需要使用git pull命令。git clone可以把远程仓库的内容克隆到本地，并将远程仓库默认命名为”origin”。 git push &lt;remote&gt; &lt;branch&gt;命令用于将本地内容推送到远程仓库上，只有具备远程仓库的写入权限，并且没有人推送过之前，这条命令才会生效，如果别人先推送了，需要先抓取别人的工作并合并到自己的工作中之后才能推送。 git remote show &lt;remote&gt;用于查看某一个远程仓库的具体新息。 git 别名上述说了很多命令，有些命令也比较长，命令很多也比较难记下来，git提供了将这些命令起个别名的功能方便使用。 git config --global alias.co checkout就将checkout起了别名co，现在使用git co就相当于git checkout。","link":"/2020/03/15/git/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/12/21/hello-world/"},{"title":"第四篇 git&github(2)","text":"git练习本地仓库最近在学java，也想巩固一下之前学习过的算法和学习新的算法，就打算用java实现，就用这个项目来加强git的使用练习。 首先在IDEA下java学习的项目里，新建了一个algorithms module，在此文件下，进入Git Bash，新建本地仓库，此时只有一个用来测试排序算法的java文件和一个iml项目配置文件。 目前java文件的内容还是空的， 编辑一下，加入main函数，文件被编辑之后，再次使用git status查看文件状态，会发现文件状态已经变成了modified，再次add，然后开始commit。 commit之后，会显示此次提交的一些信息。 远程仓库前面展示了一些Git本地的基本操作，现在假如本地文件修改好了，或者工作暂停了，准备放到github上，那么先去github上Create a new repository，最初创建的时候只有一个readme文件，下面将本地仓库同步到远程仓库上。 建立完之后，在本地仓库，将远程仓库的URL复制下来，添加远程仓库。 现在本地仓库里是没有readme文件的，如果此时想要直接push，将本地仓库推送到远程仓库的话，看看会发生什么。 跟随这个报错信息的指示，使用pull，看又会发生什么。这个原因是因为目前本地仓库和远程仓库没有任何相同的文件，根本不相干，所以会被告知无法合并，更加方便的流程是先从远程仓库拉取下来，再把本地文件加入到远程仓库下载到本地的库，然后再提交。 那就没有解决办法了嘛？不是的，可以使用一个强制的方法，添加一个可选项–allow-unrelated-histories，问题终于得以解决。 现在再去github上看看，就会发现提交成功而且push成功啦，开森，撒花~之后就要坚持练习写代码啦，刚把得勒~","link":"/2020/03/29/git-1/"},{"title":"第五篇 算法(1)--排序","text":"排序排序方法选择排序选择排序的思路是找到数组中最小的数和第一个元素交换位置，然后在剩下的元素中找到最小的元素和第二个元素交换位置，直到最后只剩一个元素，这样就是一个从小到大排好序的数组。选择排序的复杂度为O(n^2)。 插入排序插入排序的思路是将元素插入一个已经排好序的子列表中，直到整个列表都排序完成。插入排序的复杂度为O(n^2)。 冒泡排序冒泡排序的思路是每次对连续的邻居元素进行比较，两个元素是逆序排序就交换位置，否则保持不变，直到所有元素都被排序好。每次进行完一轮比较，就能将最大或者最小的元素移到其最终的位置上，当不再发生交换的时候，就说明元素已经被排好序了，冒泡排序的复杂度是O(n^2)。 归并排序归并排序的思路是利用递归的方法，将数组分为两半，各自进行归并排序的过程。其关键是如何将排好序的两个子数组也排好序，鉴于两个子数组是已经排好序了的，只需要将两个子数组依次比较。归并排序的复杂度是O(nlogn）。 快速排序快速排序的思路是挑出一个中心点，把数组分为两半，其中一半所有元素都小于这个中心点，另一半大于这个中心点，再对这两半进行递归处理，所以快速排序的关键在于这个中心点的选择了。快速排序的复杂度是O(nlogn）。 堆排序堆排序用了二叉堆，将一个数组中的所有元素添加到堆中，然后将堆中最大的元素连续移除以获得一个排好序的数组。一个二叉堆具有如下性质：是一个完全二叉树；每个节点都大于或等于它的子节点，二叉堆通常是用数组实现的，父母节点和子节点的位置满足一定的关系，假如一个在位置i的节点，它的左子节点就在位置2i+1上，右子节点在位置2i+2上。所以堆排序的关键在于二叉堆的建立和维护。堆排序的复杂度是O(nlogn)。 桶排序和基数排序桶排序和基数排序用于排序整数非常有效。 桶排序 ​ 桶排序的思路是加入数组中的元素在0到t的范围内，则把这些元素放入对应的标记上0到t的桶当中，每个桶中的元素值都是相同的。 基数排序 在桶排序中，如果元素范围过大的话，就会需要很多桶，此时就可以用基数排序。基数排序基于桶排序，只是基数排序只会用到十个桶，基于基数位置进行桶排序。 外排序当数据量大到无法一次性载入内存时，使用外排序。外排序的思路就是将大量数据拆分成小块数据，小块数据进行内排序之后，再分别合并排序。 相关java基础数组数组一旦创建了，大小就是固定的。java中声明数组变量的语法是’elementType[] arrayRefVar;’，声明数组只是创造了一个数组引用的存储位置，并没有为这个数组分配内存，创建一个数组可以使用new操作符，例如’array RefVar = new elementType[arraySize];’。 数组的拷贝数组变量是一个数组的引用，直接使用赋值语句只是让两个变量去指向同一个数组（同一片存储空间），要想真正地拷贝数组有几种方式：使用循环对数组中的元素一个一个地拷贝；使用System类中的静态方法arraycopy；使用clone方法。arraycopy的语法是’arraycopy(sourceArray,srcPos,targetArray,tarPos,length);’。","link":"/2020/04/04/sort/"},{"title":"第二篇 Linux相关(1)","text":"Basic skillsCommand of LinuxFile operationCommands that I have been familar with:lsllcdmkdircpmvrm Runnohup&amp; vi/vimcommand:i begin to insert:wq save and quit:q quit operation key:gg:move to the first linedd: delete one lineyy: copy one line[Ctrl] + [f]: Page Down[Ctrl] + [b]: Page up/:searchu:undo[Ctrl]+r:redop,P: paste","link":"/2020/03/14/work/"}],"tags":[{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[{"name":"others","slug":"others","link":"/categories/others/"},{"name":"theory","slug":"theory","link":"/categories/theory/"}]}